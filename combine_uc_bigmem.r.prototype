library(data.table)
library(parallel)
library(bigmemory)

derep_uctable_filename <- "derep_uctable.txt"
unoise_uctable_filename <- "unoise_uctable.txt"
ncores <- 20
noisy <- TRUE

# IMPORTANT NOTE: original sequence names (in derep_uc) need to contain barcodelabels. 
# The dereplicated fasta header should look like this:
# >uniqeid;barcodelabel=blahblah;size=1234

# define status message function
msg <- function(x, noisy){
	if(noisy){print(x)}
}

## read in input files

	# derep_uc is the uc table generated by dereplication of raw reads.
	# it should be generated using something like,
	# vsearch --derep_fulllength allseqs_renamed.fasta --output derep_seqs.fasta --uc derep_uctable.txt --sizeout
	# in each uc table, col 9 is the sequence that is grouped into the zOTU/centroid in col 10.
	msg("Reading in derep uc file.", noisy)
	derep_uc <- fread(derep_uctable_filename, sep='\t', header=F, stringsAsFactors=F)

	# unoise_uc is the uc table generated by mapping dereplicated reads onto unoise seeds
	# it should be generated using something like,
	# vsearch --usearch global derep_seqs.fasta --db zotu_seeds.fasta --id 0.97 --threads 24 --maxaccepts 0 --maxrejects 0 --uc unoise_uctable.txt
	msg("Reading in unoise uc file.", noisy)
	unoise_uc <- fread(unoise_uctable_filename, sep='\t', header=F, stringsAsFactors=F)

## prune useless rows from giant data.tables
	msg("Pruning derep and unoise uc objects to only contain hit rows.", noisy) 
	# prune rows that contain non-matched sequences from unoise_uc
	# here I just keep H=hit rows
	unoise_uc <- unoise_uc[unoise_uc[[1]] == "H",]
	# prune cluster records (C) and centroids (S) from derep_uc
	# centroids are useless becuase they're just in column 9 repeated.
	# might be nice to preserve these and compare to final result as a sanity check?
	# because I'm removing centroids to save time, I need to remember to add them back in
	derep_uc <- derep_uc[derep_uc[[1]] == "H",]
	
## remove size annotations from unoise_uc if they aren't also in derep_uc
	removesize <- function(x){
		return(strsplit(x, split=";size=")[[1]][1])
	}
	#if  (derep col 10 doesn't have "size=")     and    (unoise column 9 DOES have 'em)...
	if(grepl("size=", derep_uc[[10]][1]) == FALSE && grepl("size=", unoise_uc[[9]][1]) == TRUE){
		msg("Fixing names in unoise uc file.", noisy)
		msg("If you are seeing this message, you may want to pre-process that file with sed in order to remove size annotations from the 9th column. Leave off the terminal semicolon while you're at it for maximum speedup.", noisy)
		# then remove size annotations from unoise column 9 so they match.
		unoise_uc[[9]] <- simplify2array(mclapply(X=unoise_uc[[9]], FUN=removesize, mc.cores=ncores))
	}

## remove trailing semicolons from all columns where they could be (everything but zOTUs column)
	# this is faster than adding them, and it's really important later that all names match up.
	# here I assume that columns have unoform format, i.e. no mix of terminal ; and lack thereof.
	lastchar <- function(x, n=1){
		return(tail(strsplit(x, "")[[1]], n))
	}
	removelastchar <- function(x){
		return(gsub('.{1}$', '', x))
	}
	if(lastchar(derep_uc[[9]][[1]]) == ";"){
		msg("Removing terminal semicolons from derep uc column 9.", noisy)
		derep_uc[[9]] <- removelastchar(derep_uc[[9]])
	}
	if(lastchar(derep_uc[[10]][[1]]) == ";"){
		msg("Removing terminal semicolons from derep uc column 10.", noisy)
		derep_uc[[10]] <- removelastchar(derep_uc[[10]])
	}
	if(lastchar(unoise_uc[[9]][[1]]) == ";"){
		msg("Removing terminal semicolons from unoise uc column 9.", noisy)
		unoise_uc[[9]] <- removelastchar(unoise_uc[[9]])
	}

## extract sampleids from centroid names (in both unoise_uc[[9]] and derep_uc [[10]])
	get_sampleid <- function(x){
		return(gsub(pattern=".*barcodelabel=(.*);?;?", replacement="\\1", x))
	}
	msg("Extracting sampleids from unoise uc table.", noisy)
	derep_hit_sampleids <- simplify2array(mclapply(X=derep_uc[[9]], FUN=get_sampleid, mc.cores=ncores))
	# get sampleids from centroids
	# I use the unoise table here because it's smaller and should be unique
	msg("Extracting centroid sampleIDs.", noisy)
	unoise_centroid_sampleids <- simplify2array(mclapply(X=unoise_uc[[9]], FUN=get_sampleid, mc.cores=ncores))


## variable aliasing nightmare
	# this all is done because big.matrix objects MUST BE INTEGERS
	
	# zOTUs 
	# Easiest first; since their names are arbitrary I'll just make numbers instead.
	# default order for as.integer(factor(x)) is alphanumeric order, so zOTU1 will be first.
	msg("Aliasing zOTU names.", noisy)
	unoise_zOTUs_alias <- as.integer(factor(unoise_uc[[10]]))
	
	# sampleids
	msg("Aliasing sampleIDs.", noisy)
	# make vector of unique sampleids, sort it, and make index so this can be de-convoluted later
	unique_sampleids <- sort(unique(c(derep_hit_sampleids, unoise_centroid_sampleids)))
	unique_sampleids_alias <- 1:length(unique_sampleids)
	# make aliases for unoise centroids and derep hits
	derep_hit_sampleids_alias <- as.integer(factor(derep_hit_sampleids, levels=unique_sampleids))
	unoise_centroid_sampleids_alias <- as.integer(factor(unoise_centroid_sampleids, levels=unique_sampleids))
	# sanity check:
	# rows2check <- sample(1:length(unoise_centroid_sampleids), size=100)
	# check_known_sampleids <- unoise_centroid_sampleids[rows2check]
	# check_aliases <- unoise_centroid_sampleids_alias[rows2check]
	# check_predicted_sampleids <- unique_sampleids[check_aliases]
	# checkdf <- data.frame(SID1=check_known_sampleids, SID2=check_predicted_sampleids, ALIAS=check_aliases)
	# all(checkdf$SID1 == checkdf$SID2)

	# centroid sequenceIDs
	msg("Aliasing centroid names.", noisy)
	# no need for these to be translated back to anything, or to be sorted.
	# making unique centroids is a waste since they should already be unique in the unoise table
	# I'm doing it anyways for safety.
	unique_centroids <- unique(unoise_uc[[9]])
	unoise_centroid_alias <- as.integer(factor(unoise_uc[[9]], levels=unique_centroids))
	derep_centroid_alias <- as.integer(factor(derep_uc[[10]], levels=unique_centroids))

## make big matrix objects
	# these are used because they can be read by multiple processes simultaneously
	# they are also why I had to do all the above aliasing - they can ONLY be integers.
	msg("Making \"big\" matrices.", noisy)
	big_derep <- as.big.matrix(
		x=cbind(derep_hit_sampleids_alias, derep_centroid_alias), 
		type="integer",
		separated=TRUE,
		shared=TRUE
	)
	big_derep_desc <- describe(big_derep)
	
	big_unoise <- as.big.matrix(
		x=cbind(unoise_centroid_alias, unoise_zOTUs_alias, unoise_centroid_sampleids_alias),
		type="integer",
		separated=TRUE,
		shared=TRUE
	)
	big_unoise_desc <- describe(big_unoise)
	
## remove old objects from memory
	# rm()

## make zOTU table 
	msg("Constructing OTU table.", noisy)

	zOTUs <- sort(unique(unoise_zOTUs_alias))

	# function to get a row of an OTU table given the OTU name
	# this function really can't be used outside this program, because it uses the big.matrix 
	# objects created above. i just means "this zOTU" here.
	get_zOTU_row <- function(zOTU){
		# attach big.matrix objects
		big_derep_tmp <- attach.big.matrix(big_derep_desc)
		big_unoise_tmp <- attach.big.matrix(big_unoise_desc)
		
		# find which derep centroids are within zOTU_i
		zOTU_rowsTF <- big_unoise_tmp[,2] == zOTU
		centroids_i <- big_unoise_tmp[,1] [zOTU_rowsTF]
		
		# get all sampleids of original sequences within those centroids (incl. centroids themselves)
		sampids_i <- c( (big_derep_tmp[,1][big_derep_tmp[,2] %in% centroids_i]), (big_unoise_tmp[,3][zOTU_rowsTF]) )
		
		# make sampids_i a factor so that table returns empty fields
		# this makes it work when an OTU isn't observed in a sample.
		sampids_i <- factor(sampids_i, levels=unique_sampleids_alias)
		
		# make otu table row. table() will be sorted in the same order as derep_uc_sampleids_unique.
		return(as.numeric(table(sampids_i)))
	}

	zOTU_vec_list <- mclapply(X=zOTUs, FUN=get_zOTU_row, mc.cores=ncores)

